"""
Test suite for estimate_directional_spectrum function.

This test file was primarily generated by Augment and mberman who isn't Python fluent at
time of authorship. If something smells in here, don't assume there was any intelligence
behind the decision.

Run tests with:
> python3 -m pytest wave_signal_processing/tests/test_estimate_directional_spectrum.py -v
"""

import numpy as np
import pytest
from wave_signal_processing.spectral_analysis import (
    estimate_directional_spectrum,
    DirectionalMoments,
)


class TestEstimateDirectionalSpectrum:
    """Test class for estimate_directional_spectrum function."""

    def setup_method(self):
        """Set up test fixtures before each test method."""
        # Create basic test data
        self.n_frequencies = 10
        self.n_directions = 36  # 10-degree resolution
        self.directions = np.linspace(0, 360, self.n_directions, endpoint=True)
        
        # Create simple variance density (1D case)
        self.ezz_1d = np.ones(self.n_frequencies) * 0.1
        
        # Create simple directional moments (1D case)
        self.moments_1d = DirectionalMoments(
            a1=np.random.uniform(-0.5, 0.5, self.n_frequencies),
            b1=np.random.uniform(-0.5, 0.5, self.n_frequencies),
            a2=np.random.uniform(-0.5, 0.5, self.n_frequencies),
            b2=np.random.uniform(-0.5, 0.5, self.n_frequencies),
        )
        
        # Create 2D test data
        self.n_time_points = 5
        self.ezz_2d = np.ones((self.n_time_points, self.n_frequencies)) * 0.1
        
        self.moments_2d = DirectionalMoments(
            a1=np.random.uniform(-0.5, 0.5, (self.n_time_points, self.n_frequencies)),
            b1=np.random.uniform(-0.5, 0.5, (self.n_time_points, self.n_frequencies)),
            a2=np.random.uniform(-0.5, 0.5, (self.n_time_points, self.n_frequencies)),
            b2=np.random.uniform(-0.5, 0.5, (self.n_time_points, self.n_frequencies)),
        )

    def test_basic_functionality_1d(self):
        """Test basic functionality with 1D input."""
        result = estimate_directional_spectrum(
            self.ezz_1d, self.moments_1d, self.directions
        )
        
        # Check output shape
        expected_shape = (self.n_frequencies, self.n_directions)
        assert result.shape == expected_shape, f"Expected shape {expected_shape}, got {result.shape}"
        
        # Check that result is non-negative (physical constraint)
        assert np.all(result >= 0), "Directional spectrum should be non-negative"
        
        # Check that result is finite
        assert np.all(np.isfinite(result)), "Directional spectrum should be finite"

    def test_basic_functionality_2d(self):
        """Test basic functionality with 2D input."""
        result = estimate_directional_spectrum(
            self.ezz_2d, self.moments_2d, self.directions
        )
        
        # Check output shape
        expected_shape = (self.n_time_points, self.n_frequencies, self.n_directions)
        assert result.shape == expected_shape, f"Expected shape {expected_shape}, got {result.shape}"
        
        # Check that result is non-negative
        assert np.all(result >= 0), "Directional spectrum should be non-negative"
        
        # Check that result is finite
        assert np.all(np.isfinite(result)), "Directional spectrum should be finite"

    def test_energy_conservation(self):
        """Test that energy is conserved when integrating over directions."""
        result = estimate_directional_spectrum(
            self.ezz_1d, self.moments_1d, self.directions
        )

        # The function output already includes the degree-to-radian conversion factor (π/180)
        # So we integrate using degree increments directly
        direction_increment_deg = np.diff(self.directions)[0]
        integrated_energy = np.trapezoid(result, dx=direction_increment_deg, axis=-1)

        # Should approximately equal the input variance density
        # Allow for some tolerance due to numerical precision in the root finding
        np.testing.assert_allclose(
            integrated_energy, self.ezz_1d, rtol=0.1,
            err_msg="Energy should be conserved when integrating over directions"
        )

    def test_zero_moments(self):
        """Test behavior with zero directional moments."""
        zero_moments = DirectionalMoments(
            a1=np.zeros(self.n_frequencies),
            b1=np.zeros(self.n_frequencies),
            a2=np.zeros(self.n_frequencies),
            b2=np.zeros(self.n_frequencies),
        )

        result = estimate_directional_spectrum(
            self.ezz_1d, zero_moments, self.directions
        )

        # With zero moments, should get approximately isotropic distribution
        # Check that all directions have approximately equal values
        direction_variance = np.var(result, axis=-1)
        mean_values = np.mean(result, axis=-1)

        # The variance across directions should be small relative to the mean
        relative_variance = direction_variance / (mean_values + 1e-10)  # Add small value to avoid division by zero

        # Allow for some numerical precision issues
        assert np.all(relative_variance < 0.1), "Zero moments should produce approximately uniform distribution across directions"

        # Check that the result is positive and finite
        assert np.all(result >= 0), "Directional spectrum should be non-negative"
        assert np.all(np.isfinite(result)), "Directional spectrum should be finite"

    def test_input_validation(self):
        """Test input validation and error handling."""
        # Test with mismatched shapes
        wrong_ezz = np.ones(self.n_frequencies + 1)
        
        with pytest.raises((ValueError, IndexError)):
            estimate_directional_spectrum(wrong_ezz, self.moments_1d, self.directions)
        
        # Test with empty directions
        with pytest.raises((ValueError, IndexError)):
            estimate_directional_spectrum(self.ezz_1d, self.moments_1d, np.array([]))

    def test_direction_units_conversion(self):
        """Test that direction conversion from degrees to radians works correctly."""
        # Test with directions in different ranges
        directions_360 = np.linspace(0, 360, 36, endpoint=True)
        directions_180 = np.linspace(-180, 180, 36, endpoint=True)
        
        result_360 = estimate_directional_spectrum(
            self.ezz_1d, self.moments_1d, directions_360
        )
        result_180 = estimate_directional_spectrum(
            self.ezz_1d, self.moments_1d, directions_180
        )
        
        # Both should produce valid results
        assert np.all(np.isfinite(result_360)), "Result with 0-360 directions should be finite"
        assert np.all(np.isfinite(result_180)), "Result with -180-180 directions should be finite"

    def test_realistic_wave_conditions(self):
        """Test with realistic wave conditions."""
        # Create more realistic directional moments
        # Simulate a wave field with dominant direction around 45 degrees
        dominant_dir_rad = np.deg2rad(45)
        
        realistic_moments = DirectionalMoments(
            a1=0.7 * np.cos(dominant_dir_rad) * np.ones(self.n_frequencies),
            b1=0.7 * np.sin(dominant_dir_rad) * np.ones(self.n_frequencies),
            a2=0.3 * np.cos(2 * dominant_dir_rad) * np.ones(self.n_frequencies),
            b2=0.3 * np.sin(2 * dominant_dir_rad) * np.ones(self.n_frequencies),
        )
        
        result = estimate_directional_spectrum(
            self.ezz_1d, realistic_moments, self.directions
        )
        
        # Find peak direction
        peak_direction_idx = np.argmax(np.mean(result, axis=0))
        peak_direction = self.directions[peak_direction_idx]
        
        # MEM output uses oceanographic convention and peaks opposite the propagation direction.
        assert abs(peak_direction - 45) < 5, f"Peak direction {peak_direction} should be near input direction -- 45 degrees"

    def test_symmetry_properties(self):
        """Test symmetry properties of the directional spectrum."""
        # Create symmetric moments (no preferred direction)
        symmetric_moments = DirectionalMoments(
            a1=np.zeros(self.n_frequencies),
            b1=np.zeros(self.n_frequencies),
            a2=np.zeros(self.n_frequencies),
            b2=np.zeros(self.n_frequencies),
        )
        
        result = estimate_directional_spectrum(
            self.ezz_1d, symmetric_moments, self.directions
        )
        
        # Result should be approximately uniform across directions
        direction_variance = np.var(result, axis=-1)
        assert np.all(direction_variance < 1e-2), "Symmetric moments should produce uniform distribution"

    def test_numerical_stability(self):
        """Test numerical stability with extreme values."""
        # Test with very small variance density
        small_ezz = np.ones(self.n_frequencies) * 1e-10
        
        result_small = estimate_directional_spectrum(
            small_ezz, self.moments_1d, self.directions
        )
        
        assert np.all(np.isfinite(result_small)), "Should handle very small variance density"
        assert np.all(result_small >= 0), "Result should remain non-negative with small inputs"
        
        # Test with large variance density
        large_ezz = np.ones(self.n_frequencies) * 1e10
        
        result_large = estimate_directional_spectrum(
            large_ezz, self.moments_1d, self.directions
        )
        
        assert np.all(np.isfinite(result_large)), "Should handle large variance density"
        assert np.all(result_large >= 0), "Result should remain non-negative with large inputs"


class TestEstimateDirectionalSpectrumEdgeCases:
    """Additional tests for edge cases and error conditions."""

    def test_nan_handling(self):
        """Test handling of NaN values in inputs."""
        n_frequencies = 5
        directions = np.linspace(0, 360, 18, endpoint=True)

        # Test with NaN in variance density
        ezz_with_nan = np.ones(n_frequencies)
        ezz_with_nan[2] = np.nan

        moments = DirectionalMoments(
            a1=np.random.uniform(-0.5, 0.5, n_frequencies),
            b1=np.random.uniform(-0.5, 0.5, n_frequencies),
            a2=np.random.uniform(-0.5, 0.5, n_frequencies),
            b2=np.random.uniform(-0.5, 0.5, n_frequencies),
        )

        result = estimate_directional_spectrum(ezz_with_nan, moments, directions)

        # The function should handle NaN gracefully
        # NaN in ezz should propagate to the corresponding frequency in the result
        assert np.isnan(result[2, :]).all(), "NaN in ezz should propagate to result"
        assert np.isfinite(result[0, :]).all(), "Non-NaN frequencies should produce finite results"

    def test_moment_bounds_validation(self):
        """Test with directional moments at their theoretical bounds."""
        n_frequencies = 5
        directions = np.linspace(0, 360, 18, endpoint=True)
        ezz = np.ones(n_frequencies) * 0.1

        # Test with moments at maximum theoretical values
        max_moments = DirectionalMoments(
            a1=np.ones(n_frequencies) * 0.99,  # Close to theoretical max of 1
            b1=np.ones(n_frequencies) * 0.99,
            a2=np.ones(n_frequencies) * 0.99,
            b2=np.ones(n_frequencies) * 0.99,
        )

        result_max = estimate_directional_spectrum(ezz, max_moments, directions)
        assert np.all(np.isfinite(result_max)), "Should handle near-maximum moment values"

        # Test with moments at minimum theoretical values
        min_moments = DirectionalMoments(
            a1=np.ones(n_frequencies) * -0.99,  # Close to theoretical min of -1
            b1=np.ones(n_frequencies) * -0.99,
            a2=np.ones(n_frequencies) * -0.99,
            b2=np.ones(n_frequencies) * -0.99,
        )

        result_min = estimate_directional_spectrum(ezz, min_moments, directions)
        assert np.all(np.isfinite(result_min)), "Should handle near-minimum moment values"

    def test_single_direction(self):
        """Test with a single direction - expect this to fail due to algorithm limitations."""
        n_frequencies = 5
        ezz = np.ones(n_frequencies) * 0.1
        single_direction = np.array([45.0])

        moments = DirectionalMoments(
            a1=np.random.uniform(-0.5, 0.5, n_frequencies),
            b1=np.random.uniform(-0.5, 0.5, n_frequencies),
            a2=np.random.uniform(-0.5, 0.5, n_frequencies),
            b2=np.random.uniform(-0.5, 0.5, n_frequencies),
        )

        # Single direction should raise an error due to division by zero in direction increment calculation
        with pytest.raises(ZeroDivisionError):
            estimate_directional_spectrum(ezz, moments, single_direction)

    def test_high_resolution_directions(self):
        """Test with high-resolution direction array."""
        n_frequencies = 3
        ezz = np.ones(n_frequencies) * 0.1
        high_res_directions = np.linspace(0, 360, 720, endpoint=True)  # 0.5-degree resolution

        moments = DirectionalMoments(
            a1=np.random.uniform(-0.3, 0.3, n_frequencies),
            b1=np.random.uniform(-0.3, 0.3, n_frequencies),
            a2=np.random.uniform(-0.3, 0.3, n_frequencies),
            b2=np.random.uniform(-0.3, 0.3, n_frequencies),
        )

        result = estimate_directional_spectrum(ezz, moments, high_res_directions)

        expected_shape = (n_frequencies, len(high_res_directions))
        assert result.shape == expected_shape, f"Expected shape {expected_shape}, got {result.shape}"
        assert np.all(np.isfinite(result)), "High-resolution directions should produce finite result"


class TestDirectionalMomentsIntegration:
    """Test integration with DirectionalMoments class methods."""

    def test_reshape_for_solver_integration(self):
        """Test that reshape_for_solver works correctly with estimate_directional_spectrum."""
        # Test with 3D moments (multiple time points and frequencies)
        n_time = 3
        n_freq = 4
        n_dir = 18

        moments_3d = DirectionalMoments(
            a1=np.random.uniform(-0.5, 0.5, (2, n_time, n_freq)),  # Extra leading dimension
            b1=np.random.uniform(-0.5, 0.5, (2, n_time, n_freq)),
            a2=np.random.uniform(-0.5, 0.5, (2, n_time, n_freq)),
            b2=np.random.uniform(-0.5, 0.5, (2, n_time, n_freq)),
        )

        ezz_3d = np.ones((2, n_time, n_freq)) * 0.1
        directions = np.linspace(0, 360, n_dir, endpoint=True)

        result = estimate_directional_spectrum(ezz_3d, moments_3d, directions)

        expected_shape = (2, n_time, n_freq, n_dir)
        assert result.shape == expected_shape, f"Expected shape {expected_shape}, got {result.shape}"
        assert np.all(np.isfinite(result)), "3D input should produce finite result"


class TestRealWorldData:
    """Test with real-world oceanographic data."""

    def setup_method(self):
        """Set up real-world test data from actual wave measurements."""
        # Real oceanographic data from wave buoy measurements
        self.real_data = {
            "frequency": [0.0293, 0.03906, 0.04883, 0.05859, 0.06836, 0.07813, 0.08789, 0.09766, 0.10742, 0.11719, 0.12695, 0.13672, 0.14648, 0.15625, 0.16602, 0.17578, 0.18555, 0.19531, 0.20508, 0.21484, 0.22461, 0.23438, 0.24414, 0.25391, 0.26367, 0.27344, 0.2832, 0.29297, 0.30273, 0.3125, 0.32227, 0.33203, 0.35156, 0.38086, 0.41016, 0.43945, 0.46875, 0.49805, 0.6543],
            "varianceDensity": [0.410850304, 0.396847104, 0.30857523200000003, 0.17354239999999999, 0.091022336, 0.046511104000000004, 0.035759104, 0.030007296, 0.021255168, 0.011502592, 0.007251968, 0.005751808, 0.00475136, 0.004000768, 0.00300032, 0.002250752, 0.002000896, 0.0035010560000000002, 0.0027504639999999998, 0.001000448, 0.001000448, 0.001000448, 0.000499712, 0.000499712, 0.000499712, 0.000499712, 0.000499712, 0.000499712, 0.000750592, 0.000249856, 0.000249856, 0.000249856, 0.000249856, 0, 0, 0, 0, 0, 0],
            "a1": [-0.363636, -0.334311, -0.367546, -0.55132, -0.609971, -0.485826, -0.487781, -0.470186, -0.532747, -0.596285, -0.538612, -0.569892, -0.643206, -0.655914, -0.608016, -0.534702, -0.473118, -0.463343, -0.27957, -0.432063, -0.620723, -0.632454, -0.609971, -0.557185, -0.57087, -0.439883, -0.493646, -0.500489, -0.41349, -0.510264, -0.608016, -0.585533, -0.54741, -0.411535, -0.4174, -0.442815, -0.352884, -0.439883, -0.307918],
            "b1": [-0.046921, 0.01564, 0.053763, 0.026393, -0.001955, -0.006843, 0.008798, 0.034213, 0.024438, -0.006843, -0.006843, -0.012708, -0.008798, 0.062561, 0.043988, -0.006843, -0.008798, -0.024438, -0.039101, 0.013685, 0.028348, 0.00782, 0.059629, 0.020528, 0.037146, 0.021505, -0.021505, 0.004888, -0.001955, -0.005865, 0.029326, 0.014663, -0.010753, 0.024438, 0.012708, -0.014663, -0.041056, -0.004888, 0.00391],
            "a2": [0.808407, 0.756598, 0.805474, 0.839687, 0.883675, 0.897361, 0.902248, 0.901271, 0.898338, 0.859238, 0.83871, 0.827957, 0.836755, 0.845552, 0.807429, 0.725318, 0.72043, 0.730205, 0.676442, 0.754643, 0.894428, 0.86999, 0.83871, 0.876833, 0.921799, 0.898338, 0.867058, 0.908113, 0.890518, 0.908113, 0.913001, 0.903226, 0.883675, 0.884653, 0.865103, 0.893451, 0.896383, 0.921799, 0.905181],
            "b2": [0.02346, -0.11828, -0.142717, -0.044966, 0.002933, 0.076246, 0.034213, -0.033236, -0.052786, -0.102639, -0.14174, -0.100684, -0.046921, -0.158358, -0.280547, -0.244379, -0.156403, -0.229717, -0.31476, -0.222874, -0.012708, -0.083089, -0.1261, -0.099707, -0.14956, -0.11828, -0.147605, -0.15738, -0.13392, -0.1261, -0.186706, -0.160313, -0.111437, -0.112414, -0.021505, -0.114369, -0.032258, -0.046921, -0.098729]
        }

        # Convert to function parameters
        self.ezz = np.array(self.real_data["varianceDensity"])
        self.directional_moments = DirectionalMoments(
            a1=np.array(self.real_data["a1"]),
            b1=np.array(self.real_data["b1"]),
            a2=np.array(self.real_data["a2"]),
            b2=np.array(self.real_data["b2"])
        )
        self.directions = np.linspace(0, 360, 180, endpoint=True)  # 2-degree resolution

    def test_real_world_data_basic_functionality(self):
        """Test basic functionality with real oceanographic data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Check output shape
        expected_shape = (len(self.real_data["frequency"]), len(self.directions))
        assert result.shape == expected_shape, f"Expected shape {expected_shape}, got {result.shape}"

        # Check that result is non-negative (physical constraint)
        assert np.all(result >= 0), "Directional spectrum should be non-negative"

        # Check that result is finite
        assert np.all(np.isfinite(result)), "Directional spectrum should be finite"

    def test_real_world_energy_conservation(self):
        """Test energy conservation with real oceanographic data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Integrate over directions
        direction_increment_deg = np.diff(self.directions)[0]
        integrated_energy = np.trapezoid(result, dx=direction_increment_deg, axis=-1)

        # Energy conservation test with real oceanographic data

        # Should approximately equal the input variance density
        # Use more relaxed tolerance for real data due to measurement uncertainties
        np.testing.assert_allclose(
            integrated_energy, self.ezz, rtol=0.2,
            err_msg="Energy should be conserved when integrating over directions (real data)"
        )

    def test_real_world_directional_characteristics(self):
        """Test directional characteristics of real wave data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Find peak directions for each frequency
        peak_directions = self.directions[np.argmax(result, axis=1)]

        # For real wave data, peak directions should be reasonable (0-360 degrees)
        assert np.all((peak_directions >= 0) & (peak_directions <= 360)), \
            "Peak directions should be within 0-360 degrees"

        # Check that there's some directional variation (not all the same direction)
        direction_std = np.std(peak_directions[self.ezz > 0.001])  # Only consider significant energy
        assert direction_std > 1.0, "Should have some directional variation in real data"

    def test_real_world_frequency_characteristics(self):
        """Test frequency-dependent characteristics of real wave data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Check that energy decreases with frequency (typical for ocean waves)
        frequencies = np.array(self.real_data["frequency"])
        total_energy_per_freq = np.trapezoid(result, dx=2.0, axis=-1)  # 2-degree increment

        # Find the peak frequency
        peak_freq_idx = np.argmax(total_energy_per_freq)
        peak_frequency = frequencies[peak_freq_idx]

        # Peak frequency should be in reasonable range for ocean waves (0.05-0.3 Hz)
        assert 0.02 < peak_frequency < 0.5, \
            f"Peak frequency {peak_frequency:.3f} Hz should be in reasonable range for ocean waves"

    def test_real_world_zero_energy_handling(self):
        """Test handling of zero energy frequencies in real data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Find frequencies with zero variance density
        zero_energy_indices = np.where(self.ezz == 0)[0]

        if len(zero_energy_indices) > 0:
            # For zero energy frequencies, the directional spectrum should also be zero or very small
            zero_freq_results = result[zero_energy_indices, :]
            assert np.all(zero_freq_results < 1e-10), \
                "Zero energy frequencies should produce near-zero directional spectrum"

    def test_real_world_moment_consistency(self):
        """Test that directional moments are within expected ranges for real data."""
        # Check that directional moments are within theoretical bounds
        assert np.all(np.abs(self.directional_moments.a1) <= 1.0), "a1 moments should be within [-1, 1]"
        assert np.all(np.abs(self.directional_moments.b1) <= 1.0), "b1 moments should be within [-1, 1]"
        assert np.all(np.abs(self.directional_moments.a2) <= 1.0), "a2 moments should be within [-1, 1]"
        assert np.all(np.abs(self.directional_moments.b2) <= 1.0), "b2 moments should be within [-1, 1]"

        # Test that the function handles these real moment values correctly
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        assert np.all(np.isfinite(result)), "Real directional moments should produce finite results"

    def test_real_world_regression_values(self):
        """Regression test to verify the function produces consistent output values with real data."""
        result = estimate_directional_spectrum(
            self.ezz, self.directional_moments, self.directions
        )

        # Test key statistical properties of the output that should remain consistent
        # These values were computed from the current function implementation

        # Overall statistics
        total_energy = np.sum(result)
        max_value = np.max(result)
        mean_value = np.mean(result[result > 0])  # Mean of non-zero values

        # Expected values (computed from current implementation)
        expected_total_energy = 0.790004  # Sum of all directional spectrum values
        expected_max_value = 0.006608  # Maximum value in the spectrum
        expected_mean_nonzero = 0.000133  # Mean of non-zero values

        # Test with reasonable tolerance for numerical precision
        np.testing.assert_allclose(total_energy, expected_total_energy, rtol=1e-4,
                                 err_msg="Total energy should match expected value")
        np.testing.assert_allclose(max_value, expected_max_value, rtol=1e-4,
                                 err_msg="Maximum value should match expected value")
        np.testing.assert_allclose(mean_value, expected_mean_nonzero, rtol=1e-4,
                                 err_msg="Mean non-zero value should match expected value")

        # Test specific values at key locations
        # Peak energy location (frequency index 0, direction varies)
        peak_freq_spectrum = result[0, :]  # First frequency (highest energy)
        peak_direction_idx = np.argmax(peak_freq_spectrum)
        peak_value = peak_freq_spectrum[peak_direction_idx]

        expected_peak_value = 0.006608
        expected_peak_direction_idx = 91  # Direction index where peak occurs

        np.testing.assert_allclose(peak_value, expected_peak_value, rtol=1e-4,
                                 err_msg="Peak value should match expected value")
        assert peak_direction_idx == expected_peak_direction_idx, \
            f"Peak direction index should be {expected_peak_direction_idx}, got {peak_direction_idx}"

        # Test values at specific frequency-direction combinations
        test_indices = [
            (0, 0),    # First frequency, first direction
            (0, 90),   # First frequency, 90th direction (180°)
            (10, 45),  # 10th frequency, 45th direction (90°)
            (20, 120), # 20th frequency, 120th direction (240°)
        ]

        expected_values = [
            0.002799482,    # (0, 0)
            0.006597944,     # (0, 90)
            1.7293534e-8,    # (10, 45)
            4.510801e-9,     # (20, 120)
        ]

        for (freq_idx, dir_idx), expected_val in zip(test_indices, expected_values):
            actual_val = result[freq_idx, dir_idx]
            print(actual_val)
            np.testing.assert_allclose(actual_val, expected_val, rtol=1e-6,
                                     err_msg=f"Value at ({freq_idx}, {dir_idx}) should match expected")

        # Test that zero-energy frequencies produce zero output
        zero_energy_indices = np.where(self.ezz == 0)[0]
        if len(zero_energy_indices) > 0:
            zero_freq_results = result[zero_energy_indices, :]
            np.testing.assert_allclose(zero_freq_results, 0.0, atol=1e-06,
                                     err_msg="Zero energy frequencies should produce zero directional spectrum")

    def test_real_world_regression_values_dataset2(self):
        """Second regression test with different real-world oceanographic data."""
        # Different real oceanographic data from wave buoy measurements
        data2 = {
            "varianceDensity": [0.022255616,0.044010496,0.06876672,0.171541504,0.40584908799999997,0.386594816,0.26831564799999996,0.709922816,1.007746048,0.754683904,0.566888448,0.44460851200000007,0.38984499199999995,0.30632447999999995,0.324329472,0.27506688,0.26881536,0.22580531199999998,0.184044544,0.136283136,0.082020352,0.06876672,0.061264896,0.052762624,0.044511232,0.043010047999999995,0.034758656000000006,0.030507008,0.02975744,0.031507456,0.02175488,0.021005312,0.014503936,0.011752447999999999,0.007251968,0.0055009279999999995,0.004000768,0.003750912,0.00150016],
            "a1": [-0.109482,-0.069404,0.109482,0.522972,0.657869,0.691105,0.679374,0.752688,0.725318,0.702835,0.705767,0.702835,0.68915,0.721408,0.770283,0.738025,0.758553,0.782014,0.766373,0.730205,0.671554,0.659824,0.668622,0.673509,0.661779,0.659824,0.56696,0.515152,0.44477,0.504399,0.531769,0.517107,0.423265,0.396872,0.280547,0.248289,0.213099,0.15347,0.142718],
            "b1": [0.057674,0.055718,0.018573,-0.135875,-0.221896,-0.204301,-0.174976,-0.43304,-0.521017,-0.496579,-0.434995,-0.385142,-0.408602,-0.362659,-0.28739,-0.311828,-0.324536,-0.270772,-0.268817,-0.225806,-0.239492,-0.235582,-0.197458,-0.196481,-0.236559,-0.221896,-0.144673,-0.123167,-0.055718,-0.035191,-0.033236,-0.026393,-0.00782,0.127077,0.1652,0.183773,0.304008,0.288368,0.347996],
            "a2": [0.531769,0.512219,0.442815,0.507331,0.55523,0.488759,0.353861,0.351906,0.223851,0.178886,0.211144,0.300098,0.350929,0.392962,0.565005,0.503421,0.523949,0.608993,0.548387,0.490714,0.414467,0.450635,0.493646,0.480938,0.447703,0.439883,0.40567,0.505376,0.461388,0.457478,0.449658,0.423265,0.375367,0.274682,0.268817,0.205279,0.000978,-0.00782,-0.073314],
            "b2": [-0.198436,-0.217986,-0.220919,-0.246334,-0.410557,-0.434018,-0.362659,-0.707722,-0.795699,-0.745846,-0.635386,-0.500489,-0.561095,-0.535679,-0.485826,-0.55523,-0.553275,-0.427175,-0.42522,-0.370479,-0.40958,-0.502444,-0.416422,-0.347996,-0.443793,-0.473118,-0.414467,-0.391007,-0.298143,-0.185728,-0.096774,-0.14174,-0.205279,-0.078201,-0.156403,-0.174976,-0.096774,-0.127077,0.102639]
        }

        # Convert to function parameters
        ezz2 = np.array(data2["varianceDensity"])
        directional_moments2 = DirectionalMoments(
            a1=np.array(data2["a1"]),
            b1=np.array(data2["b1"]),
            a2=np.array(data2["a2"]),
            b2=np.array(data2["b2"])
        )

        result = estimate_directional_spectrum(ezz2, directional_moments2, self.directions)

        # Test key statistical properties of the output
        total_energy = np.sum(result)
        max_value = np.max(result)
        mean_value = np.mean(result[result > 0]) # Mean of non-zero values

        # Expected values (computed from current implementation)
        expected_total_energy = 3.796532081195266
        expected_max_value = 0.023765573795715807
        expected_mean_nonzero = 0.0005408165357828014

        # Test with tight tolerance for numerical precision
        np.testing.assert_allclose(total_energy, expected_total_energy, rtol=1e-10,
                                 err_msg="Dataset2: Total energy should match expected value")
        np.testing.assert_allclose(max_value, expected_max_value, rtol=1e-10,
                                 err_msg="Dataset2: Maximum value should match expected value")
        np.testing.assert_allclose(mean_value, expected_mean_nonzero, rtol=1e-10,
                                 err_msg="Dataset2: Mean non-zero value should match expected value")

        # Test peak location (frequency index 8 has highest energy)
        peak_freq_spectrum = result[8, :]  # Frequency index 8
        peak_direction_idx = np.argmax(peak_freq_spectrum)
        peak_value = peak_freq_spectrum[peak_direction_idx]

        expected_peak_value = 0.023765573795715807
        expected_peak_direction_idx = 160  # Direction index where peak occurs

        np.testing.assert_allclose(peak_value, expected_peak_value, rtol=1e-10,
                                 err_msg="Dataset2: Peak value should match expected value")
        assert peak_direction_idx == expected_peak_direction_idx, \
            f"Dataset2: Peak direction index should be {expected_peak_direction_idx}, got {peak_direction_idx}"

        # Test values at specific frequency-direction combinations
        test_indices = [
            (0, 0),    # First frequency, first direction
            (8, 45),   # Peak frequency, 45th direction (90°)
            (8, 90),   # Peak frequency, 90th direction (180°)
            (15, 120), # 15th frequency, 120th direction (240°)
            (30, 60),  # 30th frequency, 60th direction (120°)
        ]

        expected_values = [
            0.0001297997126964448,   # (0, 0)
            0.00016998854068616092,  # (8, 45)
            1.5405259481743257e-05,  # (8, 90)
            1.487800653760301e-05,   # (15, 120)
            2.055165535509192e-05,   # (30, 60)
        ]

        for (freq_idx, dir_idx), expected_val in zip(test_indices, expected_values):
            actual_val = result[freq_idx, dir_idx]
            np.testing.assert_allclose(actual_val, expected_val, rtol=1e-10,
                                     err_msg=f"Dataset2: Value at ({freq_idx}, {dir_idx}) should match expected")

        # Verify output shape
        expected_shape = (39, 180)
        assert result.shape == expected_shape, f"Dataset2: Expected shape {expected_shape}, got {result.shape}"

    def test_real_world_regression_values_dataset3(self):
        """Third regression test with additional real-world oceanographic data."""
        # Real oceanographic data from wave measurements
        data3 = {
            "frequency": [0.0293,0.03906,0.04883,0.05859,0.06836,0.07813,0.08789,0.09766,0.10742,0.11719,0.12695,0.13672,0.14648,0.15625,0.16602,0.17578,0.18555,0.19531,0.20508,0.21484,0.22461,0.23438,0.24414,0.25391,0.26367,0.27344,0.2832,0.29297,0.30273,0.3125,0.32227,0.33203,0.35156,0.38086,0.41016,0.43945,0.46875,0.49805,0.6543],
            "direction": [275.8777312690976,199.84062780723406,207.6522213347074,215.1173182818514,213.6519472617626,211.74279565646398,215.6496448664447,240.3128173948599,286.6711453767303,291.41836939983773,288.47657850768144,287.59695789430845,287.429124348384,290.87690040778506,286.1027276813969,285.3321516283498,285.2743010908847,284.89932930434753,286.60936924605136,284.21393805402084,279.5600822711496,277.216132926824,274.29689879687373,266.46041600833047,262.76974836550903,262.9971993408252,264.9749512300862,264.35171056913805,265.4108273607385,267.218974954285,262.25681802920906,254.73425874157954,251.47713085125253,237.24906769665188,183.43356027865627,99.46216379279363,104.03632555968619,90,41.185856005036214],
            "varianceDensity": [0.000499712,0.0070021120000000004,0.127780864,0.372841472,0.35733708799999997,0.310326272,0.16779059200000002,0.214802432,0.23680819199999997,0.28756992000000003,0.296822784,0.27656704000000004,0.199798784,0.117528576,0.113777664,0.110026752,0.091522048,0.098023424,0.09052160000000001,0.063014912,0.054012928,0.046011392,0.042760192,0.035508224000000005,0.029006848000000002,0.018254847999999997,0.015253504,0.016253952000000002,0.012503040000000002,0.010753024,0.009001984000000001,0.0070021120000000004,0.0060016639999999994,0.003750912,0.00300032,0.002250752,0.001750016,0.001750016,0.001000448],
            "a1": [0.066471,0.136852,0.352884,0.463343,0.451613,0.428153,0.406647,0.418377,0.548387,0.707722,0.807429,0.826002,0.806452,0.725318,0.751711,0.738025,0.740958,0.760508,0.743891,0.740958,0.742913,0.756598,0.715543,0.663734,0.654936,0.620723,0.655914,0.622678,0.584555,0.583578,0.567937,0.447703,0.382209,0.180841,0.005865,-0.117302,-0.164223,-0.129032,-0.102639],
            "b1": [-0.006843,0.379277,0.673509,0.658847,0.678397,0.692082,0.56696,0.238514,-0.164223,-0.277615,-0.269795,-0.261975,-0.253177,-0.276637,-0.217009,-0.202346,-0.202346,-0.202346,-0.221896,-0.187683,-0.125122,-0.095797,-0.053763,0.041056,0.083089,0.076246,0.057674,0.061584,0.046921,0.028348,0.077224,0.12219,0.128055,0.116325,0.097752,0.01955,0.041056,0,-0.117302],
            "a2": [0.204301,0.024438,-0.346041,-0.257087,-0.167155,-0.215054,-0.181818,-0.127077,0.025415,0.376344,0.577713,0.560117,0.506354,0.312805,0.396872,0.319648,0.374389,0.434995,0.341153,0.361681,0.472141,0.5435,0.490714,0.370479,0.386119,0.31085,0.383187,0.384164,0.360704,0.316716,0.347996,0.203324,0.174976,0.056696,0.085044,-0.044966,-0.01173,-0.183773,-0.232649],
            "b2": [0.215054,0.262952,0.565982,0.679374,0.630499,0.554252,0.345064,-0.200391,-0.531769,-0.538612,-0.478006,-0.460411,-0.434018,-0.411535,-0.362659,-0.427175,-0.396872,-0.359726,-0.390029,-0.336266,-0.254154,-0.239492,-0.286412,-0.100684,0.042033,-0.051808,-0.000978,-0.066471,-0.064516,0.025415,0.113392,0.073314,0.058651,0.152493,0.050831,0.270772,0.311828,0.374389,0.050831],
            "df": [0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.00977,0.0293,0.0293,0.0293,0.0293,0.0293,0.0293,0.2832]
        }

        # Convert to function parameters
        ezz3 = np.array(data3["varianceDensity"])
        directional_moments3 = DirectionalMoments(
            a1=np.array(data3["a1"]),
            b1=np.array(data3["b1"]),
            a2=np.array(data3["a2"]),
            b2=np.array(data3["b2"])
        )

        result = estimate_directional_spectrum(ezz3, directional_moments3, self.directions)

        # Test key statistical properties of the output
        total_energy = np.sum(result)
        max_value = np.max(result)
        mean_value = np.mean(result[result > 0]) # Mean of non-zero values

        # Expected values (computed from current implementation)
        expected_total_energy = 1.9407214806299242
        expected_max_value = 0.006680274721347801
        expected_mean_nonzero = 0.00027645605137178406

        # Test with tight tolerance for numerical precision
        np.testing.assert_allclose(total_energy, expected_total_energy, rtol=1e-10,
                                 err_msg="Dataset3: Total energy should match expected value")
        np.testing.assert_allclose(max_value, expected_max_value, rtol=1e-10,
                                 err_msg="Dataset3: Maximum value should match expected value")
        np.testing.assert_allclose(mean_value, expected_mean_nonzero, rtol=1e-10,
                                 err_msg="Dataset3: Mean non-zero value should match expected value")

        # Test peak location
        peak_freq_idx = np.argmax(ezz3)  # Find frequency with highest energy
        peak_freq_spectrum = result[peak_freq_idx, :]
        peak_direction_idx = np.argmax(peak_freq_spectrum)
        peak_value = peak_freq_spectrum[peak_direction_idx]

        expected_peak_value = 0.006680274721347801
        expected_peak_direction_idx = 28

        np.testing.assert_allclose(peak_value, expected_peak_value, rtol=1e-10,
                                 err_msg="Dataset3: Peak value should match expected value")
        assert peak_direction_idx == expected_peak_direction_idx, \
            f"Dataset3: Peak direction index should be {expected_peak_direction_idx}, got {peak_direction_idx}"

        # Test values at specific frequency-direction combinations
        test_indices = [
            (0, 0),    # First frequency, first direction
            (3, 45),   # 4th frequency (high energy), 45th direction (90°)
            (10, 90),  # 11th frequency, 90th direction (180°)
            (20, 120), # 21st frequency, 120th direction (240°)
            (35, 60),  # 36th frequency, 60th direction (120°)
        ]

        expected_values = [
            2.1688225830776168e-06,     # (0, 0)
            0.0015228792292005123,   # (3, 45)
            8.339385649101874e-05,   # (10, 90)
            8.511075197100242e-06,  # (20, 120)
            4.550054925648151e-06,  # (35, 60)
        ]

        for (freq_idx, dir_idx), expected_val in zip(test_indices, expected_values):
            actual_val = result[freq_idx, dir_idx]
            print(actual_val)
            np.testing.assert_allclose(actual_val, expected_val, rtol=1e-10,
                                     err_msg=f"Dataset3: Value at ({freq_idx}, {dir_idx}) should match expected")

        # Verify output shape
        expected_shape = (39, 180)
        assert result.shape == expected_shape, f"Dataset3: Expected shape {expected_shape}, got {result.shape}"

        # Test energy conservation
        direction_increment_deg = np.diff(self.directions)[0]
        integrated_energy = np.trapezoid(result, dx=direction_increment_deg, axis=-1)
        np.testing.assert_allclose(integrated_energy, ezz3, rtol=0.2,
                                 err_msg="Dataset3: Energy should be conserved when integrating over directions")

if __name__ == "__main__":
    # Run tests if script is executed directly
    pytest.main([__file__, "-v"])
